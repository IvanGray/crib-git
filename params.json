{
  "name": "Crib-git",
  "tagline": " Моя шпаргалка по работе GIT",
  "body": "# Моя шпаргалка по работе GIT\r\n\r\n![alt tag](https://git-scm.com/images/logo@2x.png)\r\n\r\n**Git** (произн. **«гит»**) — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.\r\n\r\n**СВК** - это система контроля версий\r\n\r\n1. Установка GIT\r\n + [Скачать и установить](#Установка-GIT);\r\n2. Кофигурация\r\n + [Общие-алиасы](#Общие-алиасы);\r\n + [Глобальные-настройки](#Глобальные-настройки-);\r\n + [Git-init](#git-init);\r\n + [Файл gitignore](#Файл-gitignore)\r\n + [Файл README.md](#Файл-readmemd);\r\n + [Горизонтальные (разделительные) линии](#Lines).\r\n3. Просмотр информации и состояние изменения файлов проекта\r\n + [Основные команды](#Просмотр-информации-и-состояние-изменения-файлов-проекта);\r\n + [git log](#git-log);\r\n4. Основы Git - Запись изменений в репозиторий\r\n + [Определение состояния файлов ($ git status)](#Определение-состояния-файлов);\r\n + [Отслеживание новых файлов](#Отслеживание-новых-файлов);\r\n + [Фиксация изменений](#Фиксация-изменений);\r\n + [Удаление файлов](#Удаление-файлов);\r\n + [Перемещение файлов](#Перемещение-файлов);\r\n5. GIT Ветление\r\n + [Branching](#GIT-Ветление);\r\n + [Merge - слияние веток](#merge---слияние-веток);\r\n + [Перезапись изменений / фиксация ошибок](#Перезапись-изменений--фиксация-ошибок);\r\n + [Конфликты](#Конфликты);\r\n + [Копилка](#Копилка);\r\n6. Работа с удаленными репозиториями\r\n + [GIT хостинг](#git-хостинг);\r\n + [Origin](#origin);\r\n + [Получение и отправка файлов на удаленный гит репозиторий](#Получение-и-отправка-файлов-на-удаленный-гит-репозиторий);\r\n + [Archive - добавить каталог в архив](#archive---добавить-каталог-в-архив);\r\n\r\n\r\n## Установка GIT\r\n\r\nСкачать и установить GIT можно на сайте : https://git-scm.com/downloads\r\n\r\n## Кофигурация\r\n\r\n###Общие алиасы\r\n\r\n**git status, git add, git commit, git checkout** — общие команды, для которых полезно иметь сокращения.\r\nДля пользователей Windows.Добавить алиасы следует в ~/.gitconfig file:\r\n\r\n\t[alias]\r\n\t\tst = status\r\n\t\tci = commit\r\n\t\tbr = branch\r\n\t\tco = checkout\r\n\t\tdf = diff\r\n\t\tdc = diff --cached\r\n\t\tlg = log -p\r\n\t\tlol = log --graph --decorate --pretty=oneline --abbrev-commit\r\n\t\tlola = log --graph --decorate --pretty=oneline --abbrev-commit --all\r\n\t\tls = ls-files\r\n\r\nВыполнить алиасы можно командами:\r\n\r\n\tgit config --global alias.co checkout\r\n\tgit config --global alias.ci commit\r\n\tgit config --global alias.st status\r\n\tgit config --global alias.br branch\r\n\tgit config --global alias.hist 'log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short'\r\n\tgit config --global alias.type 'cat-file -t'\r\n\tgit config --global alias.dump 'cat-file -p'\r\n\r\n###Глобальные настройки :\r\n\r\n\r\n- `$ git config --global user.name 'Vlad Voitovich'`\r\n- `$git config --global user.email info@example.com`\r\n\r\nВ глобальные настройки прописываем свое имя и email для комитов (commit)\r\n\r\nДля просмотра списка конфигов:\r\n- `$ git config --list `\r\n\r\n\r\n### GIT init:\r\n\r\nЧтобы создать git репозиторий в каталоге, выполните команду git init.\r\n\r\n- `$ git init`\r\n\r\n### Файл .gitignore:\r\n\r\nПредназначен для игнорирования файлов, в которых не следует отслеживать изменения. В файле достаточно указать путь к файлам:\r\n\r\n- `node_modules/`\r\n- `src/libs/`\r\n\r\n### Файл README.md\r\n\r\nПредназначен для описания проекта или инструкций.\r\n\r\n## Просмотр информации и состояние изменения файлов проекта\r\n\r\n- `$ git reflog` - основные логи последних изменений в проекте.\r\n\r\n- `$ git diff` - изменения между предыдущей и последней версии фала. ( $ git diff c784s...42asd21)\r\n\tАналог git diff > git --staged\r\n\r\n\t- `$ git diff -b` - игнорирование всех изменений в пробелах\r\n\t- `$ git diff -w` - игнорирование всех пробелов\r\n\r\n- `$ git show d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4 ` - изменения, сделанные в заданном коммите.\r\n\r\n- `$ git blame file.txt ` - изменения, сделанные в заданном коммите.\r\n\r\n- `$ git ls -tree ` - показывает дерево файлов и изменений.\r\n\r\n### GIT log\r\n\r\n- `$ git log` - просмотр логов, историю коммитов изменений проекта.\r\n\r\nВ результате выполнения **git log** в данном проекте, вы должны получить что-то вроде этого:\r\n\r\n```git\r\ncommit ca82a6dff817ec66f44342007202690a93763949\r\nAuthor: Scott Chacon <schacon@gee-mail.com>\r\nDate:   Mon Mar 17 21:52:11 2008 -0700\r\n\r\n\tchanged the version number\r\n\r\ncommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\r\nAuthor: Scott Chacon <schacon@gee-mail.com>\r\nDate:   Sat Mar 15 16:40:33 2008 -0700\r\n\r\n\tremoved unnecessary test code\r\n\r\ncommit a11bef06a3f659402fe7563abf99ad00de2209e6\r\nAuthor: Scott Chacon <schacon@gee-mail.com>\r\nDate:   Sat Mar 15 10:31:28 2008 -0700\r\n\r\n\tfirst commit\r\n```\r\nПо умолчанию, без аргументов, **git log** выводит список коммитов созданных в данном репозитории в обратном хронологическом порядке. То есть самые последние коммиты показываются первыми. Как вы можете видеть, эта команда отображает каждый коммит вместе с его контрольной суммой SHA-1, именем и электронной почтой автора, датой создания и комментарием.\r\n\r\nСуществует превеликое множество параметров команды **git log** и их комбинаций, для того чтобы показать вам именно то, что вы ищете. Здесь мы покажем вам несколько наиболее часто применяемых.\r\n\r\nОдин из наиболее полезных параметров — это -p, который показывает дельту **(разницу/diff)**, привнесенную каждым коммитом. Вы также можете использовать **-2**, что ограничит вывод до 2-х.\r\n\r\n\toptions:\r\n\r\n\t- ` --all` - отобразить все.\r\n\t- ` --color` - логи с цветом.\r\n\t- ` --graph` - показывать ASCII-граф истории ветвлений и слияний рядом с выводом лога.\r\n\t- ` --decorate` - логи с branch и tag names.\r\n\t- ` --stat` - для каждого коммита дополнительно выводить статистику по изменённым файлам.\r\n\t- ` --shortstat` - показывать только строку changed/insertions/deletions от вывода с опцией --stat.\r\n\t- ` --name-only` - показывать список изменённых файлов после информации о коммите.\r\n\t- ` --name-status` - выводить список изменённых файлов вместе с информацией о добавлении/изменении/удалении.\r\n\t- ` --abbrev-commit` - выводить только первые несколько символов контрольной суммы SHA-1 вместо всех 40..\r\n\t- ` -p` - для каждого коммита показывать дельту внесённых им изменений\r\n\t- ` --word-diff` - показывать изменения на уровне слов.\r\n\t- ` --merge` - только коммиты слияний.\r\n\t- `--pretty=oneline` - отображать коммиты в альтернативном формате. Возможные параметры: oneline, short, full, fuller и format (где вы можете указать свой собственный формат).\r\n\t- `-(n)` - показать последние n коммитов.\r\n\t- `--since, --after` - ограничить коммиты теми, которые сделаны после указанной даты.\r\n\t- `--until, --before` - ограничить коммиты теми, которые сделаны до указанной даты.\r\n\t- `--author` - показать только те коммиты, автор которых соответствует указанной строке.\r\n\t- `--committer` - показать только те коммиты, коммитер которых соответствует указанной строке.\r\n\t- ` --reverse` - история изменений в обратном порядке.\r\n\r\nМожно использовать универсальную команду:\r\n\r\n- `$ git log --oneline --graph --all --decorate`\r\n\r\n## Основы Git - Запись изменений в репозиторий\r\n\r\n### Определение состояния файлов\r\n\r\n- `$ git status` - основной инструмент, используемый для определения, какие файлы в каком состоянии находятся.\r\n\r\n### Отслеживание новых файлов\r\n\r\nДля того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда git add. Чтобы начать отслеживание файла README, вы можете выполнить следующее:\r\n\r\n- `$ git add \"file_name\"` - добавить в буфер файл.\r\n\r\n- `$ git add \"folder\"` - добавить папку с файлами в буфер.\r\n\r\n- `$ git add all` или `$ git add .`  - добавить все файлы в буфер.\r\n\r\nВы можете видеть, что файл проиндексирован по тому, что он находится в секции “Changes to be committed”. Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды **git add**, будет добавлена в историю снимков состояния. Как вы помните, когда вы ранее выполнили [Git-init](#git-init), вы затем выполнили **git add** (файлы) — это было сделано для того, чтобы добавить файлы в вашем каталоге под версионный контроль. Команда **git add** принимает параметром путь к файлу или каталогу, если это каталог, команда рекурсивно добавляет (индексирует) все файлы в данном каталоге.\r\n\r\n### Фиксация изменений\r\n\r\n- `$ git commit -m \"file_name\"`\r\n\r\n- `$ git commit -v` - более подробное напоминание того, что именно было изменено\r\n\r\n- `$ git commit --amend или git commit -a -m (-am)` - если у вас есть желание пропустить этап индексирования.\r\n\r\nЭто приведёт к тому, что в комментарий будет также помещена дельта/diff изменений, таким образом вы сможете точно увидеть всё, что сделано.) Когда вы выходите из редактора, Git создаёт для вас коммит с этим сообщением (удаляя комментарии и вывод diff'а).\r\n\r\n\r\n### Удаление файлов\r\n\r\nДля того чтобы удалить файл из Git'а, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда git rm, которая также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”.\r\n\r\n- `$ git rm <file>`\r\n\r\n### Перемещение файлов\r\n\r\n- `$ git mv file_from file_to`\r\n\r\nGit неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду mv. Единственное отличие состоит лишь в том, что mv — это одна команда вместо трёх — это функция для удобства. Важнее другое — вы можете использовать любой удобный способ, чтобы переименовать файл, и затем воспользоваться add/rm перед коммитом.\r\n\r\n\r\n## GIT Ветление\r\n\r\n![alt tag](https://git-scm.com/figures/18333fig0301-tn.png)\r\n\r\n- `$ git branch ` - получаем список веток, с которыми работаем (вездочкой отмечена текущая ветвь).\r\n\r\n- `$ git branch -a` - просмотреть все существующие ветви.\r\n\r\n- `$ git branch some_branch` - создать новый бранч (ответвится от текущего).\r\n\r\n- `$ git checkout -b` - создать и переключиться на бранч.\r\n\r\n- `$ git branch -m` - пере бранча.\r\n\r\n- `$ git branch -d some_branch` - удалить бранч  (после мерджа).\r\n\r\n- `$ git branch -r` - список всех удаленных брачей.\r\n\r\n- `$ git branch -D some_branch` - просто удалить бранч (тупиковая ветвь).\r\n\r\n- `$ git checkout some_branch` - переключиться на данную ветку.\r\n\r\n### Перезапись изменений / фиксация ошибок\r\n\r\n- `$ git reset` - говорит о том, что мы можем перемещатся на предыдущие комиты и записывать изменения снова.\r\n\r\n\tСуществует 3 типа **reset**:\r\n\r\n\t- `$ --soft` - просто возвращает нас к заданному комиту не меняя комит или файлы в буфере.\r\n\r\n\t- `$ --mixed` - перемещает head на заданный комит, при этом меня буфер.\r\n\r\n\t- `$ --hard` - полностью удаляет файлы заданного комита.\r\n\r\n### Merge - слияние веток\r\n\r\n- `$ git merge <branch>` - слияние текущей ветки с мастер.\r\n\r\n- `$ git merge <branch> --no-commit`\r\n\r\n- `$ git merge <branch>` -s ours - слияние текущей ветки , но отбрасывая любые изменения в ветвлении, используя текущее дерево, как новое.\r\n\r\n- `$ git merge --no-ff branch` - заставляет сделать коммит слияния.\r\n\r\n- `$ git merge --ff-only` - не делать быстрого слияния.\r\n\r\n- `$ git merge --abort` - оборвать слияние.\r\n\r\n### Конфликты\r\n\r\n$ git mergetool\r\n\r\nПри слиянии могут возникать конфликты. **head** указывает на код мастера.Конфликты редактируются в основном вручную.\r\n\r\n### Копилка / stash\r\n\r\nЧасто возникает такая ситуация, что пока вы работаете над частью своего проекта, всё находится в беспорядочном состоянии, а вам нужно переключить ветки, чтобы немного поработать над чем-то другим. Проблема в том, что вы не хотите делать коммит с наполовину доделанной работой только для того, чтобы позже можно было вернуться в это же состояние. Ответ на эту проблему — команда git stash.\r\n\r\n- `$ git stash save \"Change file\"` - сохраняем файлы в копилку stash.\r\n\r\nТеперь вы хотите поменять ветку, но не хотите делать коммит с тем, над чем вы ещё работаете; тогда вы прячете эти изменения. Чтобы создать новую \"заначку\", выполните git stash:\r\n\r\n```git\r\n\t$ git stash\r\n\tSaved working directory and index state \\\r\n\t  \"WIP on master: 049d078 added the index file\"\r\n\tHEAD is now at 049d078 added the index file\r\n\t(To restore them type \"git stash apply\")\r\n```\r\n- `$ git stash list` - просмотр списка файлов в копилке.\r\n\r\n- `$ git stash apply` - применить слияние файлов проекта и копилки, без удаления файлов в самой копилке.\r\n\r\n- `$ git stash drop \"name_stash\"` - удалить файлы из копилки.\r\n\r\n- `$ git stash show <stash-name> -p` - откат применения спрятанных изменений.\r\n\r\n- `$ git stash clear` - очистить копилку.\r\n\r\n- `$ git stash pop` - мы применяем файлы из копилки в проект , с удалением из копилки.\r\n\r\n## Работа с удаленными репозиториями\r\n\r\n### GIT хостинг\r\n\r\n![alt tag](https://semaphoreci.com/docs/assets/img/adding-new-project/select-github-or-bitbucket.png)\r\n\r\nДля работы с удаленными репозиториями нужен GIT хостинг. 2 самых популярных :\r\n\r\n\t1. Github (https://github.com/)\r\n\t2. Bitbucket (bitbucket.org)\r\n\r\nГлавное отличие между ними - github.com предоставляет открытый хостинг бесплатно, а для закрытых проектов платные тарифы. В отличии от github , bitbucket предоставляет бесплатно закрытый хостинг.\r\n\r\n### Origin\r\n\r\nКак только создали новый проект следует созадать [README.md](#Файл-readmemd), написать [git-init](#git-init), закомитить проект [git commit](#Фиксация-изменений), и отправить на удаленный гин хостинг.\r\n\r\nВ консоль прописываем так:\r\n\r\n\t- ` echo \"# test\" >> README.md.`\r\n\t- `$ git init`\r\n\t- `$ git add README.md`\r\n\t- `$ git commit -m \"first commit\"`\r\n\t- `$ git remote add origin https://github.com/MrVladevoit/test.git`\r\n\t- `$ git push -u origin master`\r\n\r\nЕсли уже имеется проект на локальной машине :\r\n\t- `$ git remote add origin https://github.com/MrVladevoit/test.git`\r\n\t- `$ git push -u origin master`\r\n\r\n### Получение и отправка файлов на удаленный гит репозиторий\r\n\r\n- `$ git remote` - все удаленные репозитории.\r\n\r\n- `$ git fetch <remote>` - получаем все файлы, что есть на удаленном репозитории.\r\n\r\n- `$ git clone` - клонирование репозитория с удаленного сервера на локальный компьютер.\r\n\r\n- `$ git pull` - получает все файлы с удаленного репозитория и производит сразу слеяние ([Merge](#merge---слияние-веток)).\r\n\r\n- `$ git push` - отправить файлы на удаленный гит репозиторий.\r\n\r\n- `$ git push origin <branch>` - заставляет сделать коммит слияния.\r\n\r\n\r\n### Archive - добавить каталог в архив\r\n\r\n- `$ git archive master tar -x -C /somewhere/else`\r\n\r\n- `$ git archive --format zip --output /full/path master`",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}